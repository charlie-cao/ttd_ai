Cursor大法好：和AI结对编程实践TDD

"有时候不是bug多，而是我们的代码太完美了，以至于bug都不好意思来" —— 一位喝多了咖啡的程序员

前言
====

嘿，小伙伴们！如果你正在读这篇文档，那么你很可能正在尝试用 Cursor 和 AI 一起写代码。或者你只是在摸鱼的时候不小心点进来了（没关系，这篇文档可能比你的工作更有趣）。

这是一篇记录我们在使用 Cursor 进行 TDD（测试驱动开发）时遇到的各种"有趣"问题的文档。为什么说"有趣"？因为这些问题让我们学到了很多，虽然过程有点痛苦，但是收获满满！

遇到的问题和解决方案
================

1. 项目初始化的"套娃"问题
------------------------

问题描述：
当我们试图创建项目结构时，发现自己陷入了一个奇怪的循环：
- 创建目录失败因为目录已存在
- 删除目录失败因为权限问题
- 创建文件失败因为路径不对

解决方案：
# 不要慌，让我们一步一步来
New-Item -ItemType Directory -Path "src","tests"  # 创建基本目录
New-Item -ItemType File -Path "src/__init__.py"   # 创建文件

关键是：保持冷静，一次只做一件事。就像你第一次约会一样，步子迈太大容易扯着蛋（不好意思，跑题了）。

2. 令人抓狂的导入问题
-------------------

问题描述：
ImportError: No module named 'src'
ModuleNotFoundError: No module named 'models'
# 等等一系列让人怀疑人生的导入错误

解决方案：
1. 删除 __init__.py 中的循环导入
2. 使用相对导入 from .models import User
3. 在测试中正确设置 Python 路径

记住：Python的导入就像一个迷宫，而我们就是在里面寻找奶酪的小老鼠。保持耐心，总会找到出路的！

3. 测试用例的"双重人格"
--------------------

问题描述：
测试用例在本地运行完美，但是一到 CI 环境就开始翻脸不认人。

解决方案：
1. 使用 pytest.fixture 确保测试环境的一致性
2. 为测试创建独立的内存数据库
3. 每个测试后清理数据

示例代码：
@pytest.fixture
def client():
    # 创建一个干净的测试环境，就像打扫房间一样
    # 虽然我们的代码可能很乱，但是测试环境必须整洁！
    Base.metadata.create_all(bind=engine)
    yield TestClient(app)
    Base.metadata.drop_all(bind=engine)

4. 认证功能的"套路"
----------------

问题描述：
实现认证时，测试总是返回401，但我们明明已经登录了啊！

解决方案：
# 在测试中创建认证头
@pytest.fixture
def auth_headers(client):
    # 创建一个测试用户（就像创建一个小号一样）
    response = client.post("/auth/login", ...)
    token = response.json()["access_token"]
    return {"Authorization": f"Bearer {token}"}

记住：JWT令牌就像你的门禁卡，没有它你连大门都进不去！

最佳实践总结
==========

1. 保持简单
   - 不要试图一次性写完所有代码
   - 就像吃饭一样，一口一口来，不要贪多嚼不烂

2. 测试先行
   - 先写测试，再写实现
   - 就像先画好蓝图，再盖房子

3. 及时重构
   - 代码重复不可怕，可怕的是放任不管
   - 就像房间要经常打扫一样，代码也需要定期整理

结语
====

记住：和 AI 结对编程就像和一个非常热心但有时候有点书呆子的同事一起工作。它很聪明，但偶尔也会犯傻，这时候需要你的指导。

最后，祝大家编码愉快！愿你的代码没有bug，即使有，也希望它们是有趣的bug！

---
"不要担心你的代码写得不够好，因为明天的你一定会感谢今天的你留下的注释和测试。" —— 一位深夜还在改bug的程序�� 